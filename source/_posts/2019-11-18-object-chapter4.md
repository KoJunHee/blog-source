---
layout: post
title:  "[오브젝트] 4장_설계 품질과 트레이드오프"
date:   2019-11-18
categories: Object
---

객체지향 설계란 올바른 객체에게 올바른 책임을 할당하며 낮은 결합도와 높은 응집도를 가진 구조를 만드는 것이다. 훌륭한 설계란 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다.

결합도와 응집도를 합리적인 수준으로 유지할 수 있는 원칙이 있다. 객체의 행동에 초점을 맞추는 것이다. 

이번 장에서는 책임이 아닌, 상태를 표현하는 데이터 중심의 설계를 보고 객체지향적으로 설계한 구조와 어떤 차이가 있는지 확인한다.

상속, 지연 바인딩도 중요하지만, 구현 측면에 치우쳐져 있기 때문에 객체지향 패러다임의 본질과는 거리가 멀다. 

## 01 데이터 중심의 영화 예매 시스템

상태 변경은 인터페이스의 변경을 초래하고 이 인터페이스에 의존하는 모든 객체에게 변경의 영향이 퍼진다. 그래서, 데이터에 초점을 맞춘 설계는 변경에 취약하다.

책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하기 위해 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다. 그래서 책임에 초점을 맞추면 안정적인 설계를 할 수 있다.

##### 데이터를 준비하자

데이터 중심의 설계란 객체 내부에 저장되는 데이터를 기반으로 시스템으 분할하는 방법이다.

99 Page

객체의 종류를 저장하는 인스턴스 변수 (movieType) 와 인스턴의 종류에 따라 배타적으로 상용될 인스턴스 변수 (discountAmount, discountPercent) 를 하나의 클래승 안에 포함시키는 방식은 데이터 중심 설계에서 흔히 보인다.

메세지를 수신한 객체는 메세드를 실행해 요청에 응답한다. Screening 이 Movie 에게 처리를 위임하는 이유는 요금을 계산하는데 필요한 기본 요금과 할인 정책을 가장 잘 알고 있는 객체가 Movie 이기 때문이다. 

자율적인 객체란 자신의 상태를 직접 관리하고 스스로의 결정에 따라 행동하는 객체이다. 객체의 자율성을 보장하기 위해서는 필요한 정보와 정보에 기반한 행동을 같은 객체 안에 모아두어야 한다.

결과적으로 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화 하는 것이다. 

자율적인 객체는 자신에게 할당된 책임을 수행하던 중에 필요한 정보를 알지 못하거나 외부의 도움이 필요한 경우 적절한 객체에게 메세지를 전송해 협력을 요청한다.

##### 영화를 예매하자

106 Page

## 02 설계 트레이드오프

데이터 중심 설계와 책임 중심 설계 구현을 위해 캡슐화, 응집도, 결합도를 사용한다.

##### 캡슐화

상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기위해서다. 구현이란, 나중에 변경될 가능성이 높은 어떤 것이다. 변경될 가능성이 높은 것을 구현, 상대적으로 안정적인 것을 인터페이스라고 한다.

캡슐화란, 변경 가능성이 높은 것을 객체 내부로 숨기는 추상화 기법이다.

##### 응집도와 결합도

응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도이다. 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지이다.

결헙도는 의존성의 정도이다. 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지이다.

응집도가 높은 설계에서는 하나의 요구사항 변경을 반영하기 위해 오직 하나의 모듈만 수정하면 된다. 응집도가 낮은 설계에서는 하나의 원인에 의해 변경해야 하는 부부닝 다수의 모듈에 분산돼 있기 때문에 여러 모듈을 동시 수정해야한다.

내부 구현을 변경하면 이것이 다른 모듈에 영향을 미치는 경우 두 모듈 사이의 결합도가 높다고 말한다. 반면, 퍼블릭 인터페이스를 수정했을 때만 다른 모듈에 영향을 미치면 결합도가 낮다고 말한다. 그래서 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있다. 이것이 "인퍼페이스에 대해 프로그래밍 하라" 이다.

## 03 데이터 중심의 영화 예매 시스템의 문제점

데이터 중심 설계의 문제점이다.

1. 캡슐화 위반
2. 높은 결합도
3. 낮은 응집도

'예매하라' 라는 메세지를 처리하기 위해 적합한 객체로 Screening 을 선택하는 데는 두가지 단계가 있다.

1. 영화 예매를 할 수 있는 적절한 역할이 무엇인가 ?
2. 역할을 수행할 객체로 Screening 인스턴스를 선택한다.

##### 캡슐화 위반

```java
public class Movie {
	private Money fee;
  
  public Money getFee(){
    retrun fee;
  }
  
  public void settFee(Money fee){
    this.fee = fee;
  }
}
```

getFee 와 setFee 메서드는 Movie 내부에 Money 타입의 fee 라는 인스턴스 변수가 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 드러낸다.

설계할 때 협력을 고민하지 않으면, 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 되는 경향이 있다. 이것이 '추측에 의한 설계 전략' 이다.

##### 높은 결합도

fee 타입을 변경한다고 가정해보자. 이를 위해, getFee 메서드의 반환 타입도 수정해야한다. 그리고, getFee 메서드를 호출하는 ReservationAgency 의 구현도 변경된 타입에 맞게 수정해야 한다.

결합도 측면에서 또 다른 단점은, 여러 데이터 객체들을 사용하는 제어로직이 특정 객체 안에 집중된다는 것이다. 그래서 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다. 즉, 어떤 데이터 객체를 변경하더라도 제어 객체를 함께 변경해야 한다.

##### 낮은 응집도

서로 다른 이유로 변경되는 코드가, 하나의 모듈 안에 공존하면 응집도가 낮다고 한다.

단일 책임 원칙이란, 클래스는 단 한가지의 변경 이유만 가져야 한다는 것이다.

## 04 자율적인 객체를 향해

##### 캡슐화를 지켜라

객체는 자신이 어떤 데이터를 가지고 있는지 내뷰에 캡슐화하고 외부에 공개하면 안된다. 객체는 스스로의 상태를 책임지고 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근해야한다.

속성의 가시성을 private 으로 설정해도, 접근자와 수정자를 통해 속성을 외부에 제공하고 있으면 캡슐화를 위반한 것이다.

##### 스스로 자신의 데이터를 책임지는 객체

객체 내부에 저장되는 데이터보다, 객체가 협력에 참여하며 수행할 책임을 정의하는 오퍼레이션이 중요하다.

## 05 하지만 여전히 부족하다

##### 캡슐화 위반

기간 조건을 판단하는

```java
isDiscountable(DayofWeek dayOfWeek, LocalTime time)
```

메서드의 시그니처을 보면, 객체 내부에 요일과 시간정보가 인스턴스 변수로 포함돼 있다는 것을 인터페이스를 통해 외부에 노출한다.

DiscountCondition 의 속성을 변경하면, isDiscountable 메서드의 파라미터를 수정하고 해당 메서드를 사용하는 모든 클라이언트도 함께 수정해야한다.

캡슐화란, 변할 수 있는 어떤 것이라도 감추는 것이다.

##### 높은 결합도

결합도가 높으면 한 객체의 구현을 변경하면 다른 객체에 변경의 영향이 전파될 확률이 높다. 

##### 낮은 응집도

응집도가 낮은 이유는 캡슐화를 위반했기 때문이다.

## 06 데이터 중심 설계의 문제점

변경에 취약한 이유는

1. 너무 이른시기에 데이터를 결정하도록 강요한다.
2. 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

#####데이터 중심 설계는 객체의 행동보다 상태에 초점을 맞춘다.

데이터는 구현의 일부다. 

데이터 중심 설계는 설계 초반에 데이터에 관해 결정하도록 강요해서 너무 이른시기에 내부 구현에 초점을 맞춘다. 

##### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 결정한다.

협력의 문맥 안에서 필요한 책임을 결정하고 이를 수행할 적절한 객체를 결정하는 것이 가장 중요하다.

---

오브젝트 <조영호>